### **Part 1: Celebrate Small Wins with "Sonner" Toasts**

The goal is to provide immediate, positive feedback for completing a core task. This reinforces the user's action and makes progress feel tangible.

**Action:** We will modify the `MarkCompleteButton.tsx` component to trigger a toast notification on successful completion.

**File to Edit:** `components/library/MarkCompleteButton.tsx`

**Implementation:**

1.  **Import `toast` and the `CheckCircle2` icon** from `sonner` and `lucide-react`.

2.  **Modify the `updateProgressMutation`:** In the `onSuccess` callback, add a call to `toast.success()`.

```typescript
// In components/library/MarkCompleteButton.tsx

'use client';

import { Button } from '@/components/ui/button';
import { fetchJson } from '@/lib/api';
import { queryKeys } from '@/lib/queryKeys';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Check, CheckCircle, CheckCircle2 } from 'lucide-react'; // <-- ADD CheckCircle2
import { useRouter } from 'next/navigation';
import { useState } from 'react';
import { toast } from 'sonner'; // <-- ADD THIS

// ... (interface remains the same)

export default function MarkCompleteButton({
  articleId,
  isCompleted: initialCompleted,
}: MarkCompleteButtonProps) {
  const router = useRouter();
  const queryClient = useQueryClient();
  const [isCompleted, setIsCompleted] = useState(initialCompleted);

  const updateProgressMutation = useMutation({
    mutationFn: async ({ completed }: { completed: boolean }) => {
      // ... (mutation logic remains the same)
    },
    onSuccess: (_, variables) => {
      setIsCompleted(variables.completed);
      queryClient.invalidateQueries({ queryKey: queryKeys.progress.articles() });

      // --- START: ADD THIS BLOCK ---
      if (variables.completed) {
        toast.success("Lesson Completed!", {
          description: "Your progress has been saved.",
          icon: <CheckCircle2 className="h-4 w-4" />,
        });
      }
      // --- END: ADD THIS BLOCK ---
      
      router.refresh();
    },
    onError: (error) => {
      toast.error(error instanceof Error ? error.message : 'Failed to update progress');
    },
  });

  // ... (rest of the component remains the same)
}
```

---

### **Part 2: Celebrate Major Milestones with a "Domain Complete" Modal**

The goal here is to create a significant, celebratory moment when a user achieves a major milestone. This is much more impactful than a simple toast.

**Action:** We will modify the `markLessonAsCompleted` server action. When it detects that a domain has been completed, it will return a flag. The client-side component that calls this action will then use this flag to trigger a congratulatory modal.

**Files to Edit:**
1.  `app/actions/progress.ts`
2.  The client component where lesson completion is triggered (likely `components/library/MarkCompleteButton.tsx` or a similar component).

**Implementation:**

**1. Update the Server Action (`app/actions/progress.ts`):**

The server action already checks for domain completion. We just need to ensure it reliably returns a `domainCompleted` flag. Your existing code is already set up perfectly for this. No changes are needed here if it already returns `{ success: true, domainCompleted: !!completion }`.

**2. Trigger the Modal from the Client:**

Let's assume the "Mark Complete" button is the primary way a user finishes the last lesson in a domain. We will enhance it to handle the `domainCompleted` response.

```typescript
// This is a conceptual example. You would integrate this logic
// into the component that calls `markLessonAsCompleted`. Let's create a
// new component for clarity called `LessonCompletionHandler.tsx` that you can
// place on your lesson page.

// Create a new file: components/library/LessonCompletionHandler.tsx
'use client';

import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Award } from 'lucide-react';
import Link from 'next/link';

interface DomainCompletionModalProps {
  isOpen: boolean;
  onClose: () => void;
  domainTitle: string;
  certificateUrl: string;
}

function DomainCompletionModal({ isOpen, onClose, domainTitle, certificateUrl }: DomainCompletionModalProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md text-center">
        <DialogHeader className="space-y-4">
          <Award className="mx-auto h-12 w-12 text-yellow-500" />
          <DialogTitle className="text-2xl font-bold">Domain Complete!</DialogTitle>
          <DialogDescription>
            Congratulations! You have mastered the core competencies of{' '}
            <span className="font-semibold text-gray-900">{domainTitle}</span>.
          </DialogDescription>
        </DialogHeader>
        <div className="mt-6 flex flex-col gap-4">
          <Button asChild size="lg" className="bg-gray-900 hover:bg-gray-800 text-white">
            <Link href={certificateUrl}>View Your Certificate</Link>
          </Button>
          <Button variant="outline" onClick={onClose}>
            Continue Learning
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

// Now, in the component that marks lessons complete, you'd add this state management.
// For example, enhancing your `MarkCompleteButton.tsx` or a parent component.

// In your lesson page component...
// You'll need to manage the state for the modal.
const [modalOpen, setModalOpen] = useState(false);
const [completionData, setCompletionData] = useState({ domainTitle: '', certificateUrl: '' });

// When the `markLessonAsCompleted` action is called:
const handleMarkComplete = async () => {
  const result = await markLessonAsCompleted(domainId, moduleId, lessonId);
  if (result.success && result.domainCompleted) {
    // Assuming you can get the domain title and certificate URL
    setCompletionData({
      domainTitle: 'Mastery of Capital Allocation', // Fetch this dynamically
      certificateUrl: `/certificates/${domainId}`
    });
    setModalOpen(true);
  }
};

// And in your JSX, render the modal:
<DomainCompletionModal
  isOpen={modalOpen}
  onClose={() => setModalOpen(false)}
  domainTitle={completionData.domainTitle}
  certificateUrl={completionData.certificateUrl}
/>
```

---

### **Part 3: Feature the "Learning Streak" Prominently**

The goal is to make the learning streak a central, motivating element of the user's dashboard, encouraging daily engagement.

**Action:** You already have a `LearningStreak.tsx` component. We just need to ensure it's placed in a highly visible position on the dashboard and is visually engaging.

**File to Edit:** `app/(app)/dashboard/page.tsx` (and its client component `FocusedDashboard.tsx`)

**Implementation:**

1.  **Fetch the Data:** Your `assembleDashboardData` function in `lib/dashboard-assembler.ts` should calculate the user's current learning streak. Your existing code shows this is already done (`currentStreak`).

2.  **Position the Component:** In `components/dashboard/FocusedDashboard.tsx`, place the `LearningStreak.tsx` component in a prominent location. A great spot is in the header section or as one of the first cards the user sees.

```typescript
// In components/dashboard/FocusedDashboard.tsx

// ... imports
import LearningStreak from '@/components/dashboard/LearningStreak';

export default function FocusedDashboard({
  // ... other props
  currentStreak,
}: FocusedDashboardProps) {

  // ...

  return (
    <div className="space-y-8 px-6 lg:px-8 py-8 max-w-screen-2xl mx-auto">
      {/* Personalized Header */}
      <div className="text-center space-y-4">
        <h1 className="text-4xl font-bold text-gray-900">
          {getGreeting()}, {user.user_metadata?.full_name?.split(' ')[0] || 'there'}
        </h1>
        {/* --- ADD THE STREAK BADGE HERE --- */}
        {currentStreak > 0 && (
          <div className="flex items-center justify-center">
            <Badge variant="outline" className="text-orange-600 border-orange-200 px-4 py-2 text-lg font-semibold">
              ðŸ”¥ {currentStreak} Day Learning Streak!
            </Badge>
          </div>
        )}
        {/* --- END OF ADDITION --- */}
      </div>

      {/* Or, as a prominent card */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-1">
          {/* You can also feature the component as a full card */}
          <LearningStreak currentStreak={currentStreak} longestStreak={/* You'll need to fetch this */} />
        </div>
        <div className="lg:col-span-2">
          {/* Other dashboard content */}
        </div>
      </div>

      {/* ... rest of the dashboard shelves */}
    </div>
  )
}
```

This simple, three-part plan will significantly enhance user engagement by adding clear, positive feedback loops at key moments in their learning journey, all without requiring major architectural changes.