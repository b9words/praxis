### **Part 1: The Strategic Framework â€” Event-Driven Notifications**

The system will be built around a simple but powerful concept: **database events trigger notifications.** Instead of running complex daily jobs to check for user activity, we will use Supabase's built-in capabilities to react to events in real-time.

**The Core User Journey & Email Triggers:**

1.  **User Signs Up:**
    *   **Trigger:** New user is created in `auth.users`.
    *   **Email:** "Welcome to Praxis" (Day 0).
    *   **Follow-ups:** "Your First Clear Step" (Day 1), "Discover Simulations" (Day 3).
2.  **User Completes a Domain:**
    *   **Trigger:** A new row is inserted into the `DomainCompletion` table.
    *   **Email:** "Congratulations! You've Mastered [Domain Name]."
3.  **User Becomes Inactive:**
    *   **Trigger:** A scheduled job (cron) runs daily to find users who haven't logged in for 7 days.
    *   **Email:** "Re-engage: Your Next Challenge Awaits."
4.  **Weekly Summary (Existing):**
    *   **Trigger:** Your existing cron job for `/api/email/weekly-summary`.
    *   **Email:** The weekly progress report.

---

### **Part 2: The Technical Implementation Plan**

This plan is designed to be straightforward and leverages your existing file structure.

#### **Step 1: Enhance Your Database Schema (`prisma/schema.prisma`)**

We need a new table to manage the email triggers from your admin panel. This is the key to making the system controllable without code changes.

```prisma
// In prisma/schema.prisma

model AutomatedEmail {
  id        String   @id @default(uuid())
  eventName String   @unique // e.g., 'user_signed_up', 'domain_completed', 'user_inactive'
  subject   String
  template  String   // Corresponds to your React Email component names (e.g., 'WelcomeEmail')
  delayDays Int      @default(0) // Delay in days after the event (for drip campaigns)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("automated_emails")
}
```

*   **Action:** Add this model to your `schema.prisma` file and run `npm run db:push` to sync your database.

#### **Step 2: Create a New Admin Page (`app/(app)/admin/system/emails/page.tsx`)**

This page will allow you to view, create, and edit the automated email triggers. It will be a simple CRUD (Create, Read, Update, Delete) interface for the `AutomatedEmail` table.

*   **UI:** A table listing each `AutomatedEmail` record.
*   **Fields to Edit:** `eventName`, `subject`, `template`, `delayDays`, and an `isActive` toggle.
*   **Functionality:**
    *   `List`: Show all configured automated emails.
    *   `Create`: Add a new trigger (e.g., a "Day 7" follow-up email for new users).
    *   `Update`: Change the subject, delay, or template for an existing trigger.
    *   `Toggle`: Quickly enable or disable an email trigger without deleting it.

#### **Step 3: Implement the Trigger Logic (Supabase Webhooks & Edge Functions)**

This is the core of the automated system. We will use Supabase's Database Webhooks to call a new Supabase Edge Function whenever a relevant event occurs.

**A. The "Welcome Sequence" Trigger:**

1.  **Supabase Auth Hook (Webhook):**
    *   **Action:** In your Supabase project dashboard, go to `Database` -> `Webhooks`.
    *   **Create a new webhook:**
        *   **Table:** `auth.users`
        *   **Events:** `INSERT`
        *   **Type:** `HTTP Request`
        *   **URL:** Your new Supabase Edge Function URL (e.g., `https://<your-project>.supabase.co/functions/v1/handle-db-trigger`)
        *   **Method:** `POST`
        *   **Headers:** Add an `Authorization` header with `Bearer <your-supabase-service-role-key>`.

2.  **The `handle-db-trigger` Edge Function:**
    *   **Action:** Create a new Edge Function at `supabase/functions/handle-db-trigger/index.ts`.
    *   **Logic:** This function is the central router for all database events.

    ```typescript
    // In supabase/functions/handle-db-trigger/index.ts
    import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
    import { Resend } from "npm:resend"; // Use npm specifier for Deno

    serve(async (req) => {
      const payload = await req.json();
      const { type, table, record } = payload;

      const supabaseAdmin = createClient(
        Deno.env.get("SUPABASE_URL")!,
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
      );

      const resend = new Resend(Deno.env.get("RESEND_API_KEY"));

      try {
        // --- Trigger for New User Signup ---
        if (table === 'users' && type === 'INSERT' && record.email) {
          await handleNewUser(supabaseAdmin, resend, record);
        }

        // --- Trigger for Domain Completion ---
        if (table === 'DomainCompletion' && type === 'INSERT') {
          await handleDomainCompletion(supabaseAdmin, resend, record);
        }

        return new Response("Webhook processed", { status: 200 });

      } catch (error) {
        console.error("Webhook Error:", error.message);
        return new Response(`Webhook Error: ${error.message}`, { status: 400 });
      }
    });
    ```

3.  **The `handleNewUser` Logic:** This function queries your new `AutomatedEmail` table to find all emails associated with the `user_signed_up` event and sends them.

    ```typescript
    // Add this inside your handle-db-trigger function
    async function handleNewUser(supabase, resend, userRecord) {
      const { data: emails, error } = await supabase
        .from("automated_emails")
        .select("*")
        .eq("eventName", "user_signed_up")
        .eq("isActive", true);

      if (error) throw error;
      if (!emails) return;

      for (const email of emails) {
        // Here you would render your React Email template to HTML
        // For simplicity, we'll use a placeholder.
        const html = `<h1>${email.subject}</h1><p>Welcome, ${userRecord.email}!</p>`;

        // The `delayDays` is handled by a scheduler (see Part 4)
        // For now, we only send Day 0 emails.
        if (email.delayDays === 0) {
          await resend.emails.send({
            from: "Praxis Program <onboarding@yourdomain.com>",
            to: userRecord.email,
            subject: email.subject,
            html: html,
          });
        }
      }
    }
    ```

**B. The "Domain Completion" Trigger:**

*   **Supabase Database Webhook:**
    *   **Action:** Create another webhook, this time for the **`DomainCompletion`** table on **`INSERT`** events. Point it to the same Edge Function URL.
*   **The `handleDomainCompletion` Logic:** This function fetches the relevant user and domain details and sends the congratulatory email.

    ```typescript
    // Add this inside your handle-db-trigger function
    async function handleDomainCompletion(supabase, resend, completionRecord) {
      const { data: emailConfig } = await supabase
        .from("automated_emails")
        .select("*")
        .eq("eventName", "domain_completed")
        .eq("isActive", true)
        .single();

      if (!emailConfig) return;

      // Get user email and domain title
      const [{ data: user }, { data: domain }] = await Promise.all([
        supabase.auth.admin.getUserById(completionRecord.userId),
        // Assume you have a `domains` table or can fetch from your curriculum data
        // For simplicity, we use the domainId from the record.
        Promise.resolve({ data: { title: completionRecord.domainId } })
      ]);

      if (!user?.user?.email) return;

      const subject = emailConfig.subject.replace('[Domain Name]', domain.title);
      const certificateUrl = `https://<your-app-url>/certificates/${completionRecord.domainId}`;
      const html = `<h1>${subject}</h1><p>View your new certificate: <a href="${certificateUrl}">here</a></p>`;

      await resend.emails.send({
        from: "Praxis Program <rewards@yourdomain.com>",
        to: user.user.email,
        subject: subject,
        html: html,
      });
    }
    ```

---

### **Part 4: Handling Delayed Emails & Inactivity (The Cron Job)**

Real-time webhooks are perfect for immediate events, but for delayed actions (drip campaigns) and inactivity checks, a scheduled job is the best, non-complicated approach.

1.  **Create a New API Route (`app/api/cron/process-emails/route.ts`):**
    *   This route will be triggered daily by a cron job service (like Vercel Cron Jobs or Supabase Scheduled Functions).
    *   It will be password-protected to prevent public access.

2.  **Logic for the Cron Job API Route:**

    ```typescript
    // In app/api/cron/process-emails/route.ts
    import { NextResponse } from 'next/server';
    import { createClient } from '@supabase/supabase-js';

    export async function GET(request: Request) {
      // --- Security Check ---
      const authHeader = request.headers.get('authorization');
      if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
        return new Response('Unauthorized', { status: 401 });
      }

      const supabaseAdmin = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      );

      // --- 1. Process Drip Campaigns (e.g., Welcome Sequence Day 1, Day 3) ---
      const { data: signupEmails } = await supabaseAdmin
        .from("automated_emails")
        .select("*")
        .eq("eventName", "user_signed_up")
        .eq("isActive", true)
        .gt("delayDays", 0);

      if (signupEmails) {
        for (const email of signupEmails) {
          const targetDate = new Date();
          targetDate.setDate(targetDate.getDate() - email.delayDays);
          
          // Find users who signed up `delayDays` ago
          const { data: users } = await supabaseAdmin.auth.admin.listUsers({
            // This is a simplified query. A real implementation might require
            // storing signup dates in your `profiles` table for easier querying.
          });
          // Logic to filter users who signed up on the targetDate...
          // Then send them the email...
        }
      }

      // --- 2. Process Inactivity Emails ---
      // ... Logic to find users who haven't logged in for 7 days ...
      // ... Then send the 'user_inactive' email ...

      return NextResponse.json({ success: true });
    }
    ```

3.  **Configure the Cron Job:**
    *   **Action:** In your hosting provider (Vercel) or Supabase, set up a scheduled job.
    *   **Schedule:** `0 0 * * *` (Once per day at midnight UTC).
    *   **URL:** `https://<your-app-url>/api/cron/process-emails`
    *   **Method:** `GET`
    *   **Headers:** Add an `Authorization` header with `Bearer <your-cron-secret>`.

This system gives you a powerful, flexible, and admin-controllable way to manage automated user engagement without overcomplicating your architecture. It uses the best tool for each job: real-time webhooks for instant events and a simple daily cron job for scheduled and inactivity-based triggers.